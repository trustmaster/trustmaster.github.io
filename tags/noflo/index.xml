<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Noflo on A system brought to life</title>
    <link>http://blog.kodigy.com/tags/noflo/index.xml</link>
    <description>Recent content in Noflo on A system brought to life</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Vladimir Sibirov. Code released under the MIT license.</copyright>
    <atom:link href="http://blog.kodigy.com/tags/noflo/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Development efficiency challenges in NoFlo</title>
      <link>http://blog.kodigy.com/post/noflo_development_efficiency/</link>
      <pubDate>Mon, 07 Nov 2016 17:39:26 +0100</pubDate>
      
      <guid>http://blog.kodigy.com/post/noflo_development_efficiency/</guid>
      <description>

&lt;h1 id=&#34;development-efficiency-challenges-in-noflo&#34;&gt;Development efficiency challenges in NoFlo&lt;/h1&gt;

&lt;p&gt;Programming with NoFlo is getting more and more smooth with every release. However, if maintaining a NoFlo application is your day-to-day job you may notice some inconveniences.&lt;/p&gt;

&lt;h2 id=&#34;defining-new-components-is-slow&#34;&gt;Defining new components is slow&lt;/h2&gt;

&lt;p&gt;Every time you add a new component you have to define a pretty massive hash map of its ports, their data types and preferably at least descriptions. This is cool as it encourages you to declare as many details as possible but it’s not very friendly to rapid prototyping where you want just to list the ports and get your hands on the code and add details later.&lt;/p&gt;

&lt;h3 id=&#34;solutions&#34;&gt;Solutions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Reduce minimal boilerplate for new components&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;wiring-up-all-the-ports-is-slow-fbp&#34;&gt;Wiring up all the ports is slow (.FBP)&lt;/h2&gt;

&lt;p&gt;OK, maybe it wouldn’t be so slow if it was all done in Flowhub but until those glory days when we could switch all our projects to Flowhub, the problem persists.&lt;/p&gt;

&lt;p&gt;Components have many ports. Say there are 8 components in the graph, each of them has 4 ports and there are also 2 inports and 2 outports in the graph. This could make at least 32 connections required for the graph to run. Which is writing 32 lines of code in .FBP, and what’s worse keeping them all and the whole picture in mind. Using &lt;a href=&#34;https://noflojs.org/visualize/&#34;&gt;NoFlo visualize tool&lt;/a&gt; helps a lot here though. But then you close that graph, open it 3 months later to add a new branch and rewire some connection and you can’t do it without a migraine or two.&lt;/p&gt;

&lt;p&gt;With Flowhub it’s a bit easier b/c you see the picture, attach and detach connections and rewire it more or less effectively.&lt;/p&gt;

&lt;h3 id=&#34;solutions-1&#34;&gt;Solutions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Reduce the amount of ports and connections in the graphs&lt;/li&gt;
&lt;li&gt;Use more terse syntax than .FBP&lt;/li&gt;
&lt;li&gt;Switch to Flowhub eventually&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;can-t-tell-if-a-graph-works-until-everything-is-wired&#34;&gt;Can&amp;rsquo;t tell if a graph works until everything is wired&lt;/h2&gt;

&lt;p&gt;It’s easier to code something in small iterations one piece at a time: add a component, add tests for it, add another component with tests, wire these two components, make sure they work together, add a third component, etc. then you have the whole graph and tests for it. This requires a lot of rewiring and intermediate tests.&lt;/p&gt;

&lt;p&gt;As described above, in .FBP rewiring is expensive. In Flowhub rewiring is cheaper but still requires quite some clicks and drags, but what’s more important Flowhub/NoFlo won’t let you run the program until the graph is all wired up correctly. So what we do in practice is not trying anything until the entire graph is complete with all the components and connections. Which is a lot of headache wiring first (in .FBP) and then lots of bugs when it’s finally wired (both .FBP and Flowhub).&lt;/p&gt;

&lt;h3 id=&#34;solutions-2&#34;&gt;Solutions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Do write tests for components and subgraphs&lt;/li&gt;
&lt;li&gt;Prefer mid-sized components and subgraphs so that each of them can have a test without too much hassle&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;doesn-t-show-which-component-failed-stuck&#34;&gt;Doesn&amp;rsquo;t show which component failed/stuck&lt;/h2&gt;

&lt;p&gt;This is the hardest thing when debugging. So you know that the graph just hangs somewhere, at some component. But you don’t know which one. There is &lt;a href=&#34;https://www.npmjs.com/package/flowtrace&#34;&gt;Flowtrace&lt;/a&gt; at your service but reading a flowtrace of a real application is hell of a job, there can be hundreds of socket events and you have to figure out which ones are actually &lt;em&gt;missing&lt;/em&gt; from those hundreds. Replaying a flowtrace in Flowhub with &lt;code&gt;flowtrace-replay&lt;/code&gt; is slightly better but the problem persists: you need to find the missing piece of jigsaw.&lt;/p&gt;

&lt;p&gt;A less critical but also annoying thing is that when something fails somewhere, you see the error in the output and it maybe even contains a stack trace to some extent but it doesn’t contain the process or component name, which you’d like to know in first place when opening an error output.&lt;/p&gt;

&lt;h3 id=&#34;solutions-3&#34;&gt;Solutions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Always include component names in stack traces&lt;/li&gt;
&lt;li&gt;Always catch and log errors&lt;/li&gt;
&lt;li&gt;Visual flowtraces in Flowhub&lt;/li&gt;
&lt;li&gt;How could we fix the missing jigsaw problem?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conditionals-branching-is-hard&#34;&gt;Conditionals/branching is hard&lt;/h2&gt;

&lt;p&gt;There are no simple IFs in FBP. No such thing. If you need to check something, it’s either inside a component or a whole branch of the graph. Usually if you need an IF in the graph, it results into 2 graphs. Which takes time wiring up. And duplicates the code. And duplicates the bugs.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Stop thinking in control flow you idiots, you should think data flow here!&amp;rdquo; - says the Captain FBP. Yes, sir, how do I think such things in data flow, sir?&lt;/p&gt;

&lt;h3 id=&#34;solutions-4&#34;&gt;Solutions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Simple graphs are easier to add conditionals to&lt;/li&gt;
&lt;li&gt;If you need to duplicate a branch, put it in a subgraph&lt;/li&gt;
&lt;li&gt;Keep control logic inside components&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;components-flourish-with-promises-callbacks&#34;&gt;Components flourish with promises/callbacks&lt;/h2&gt;

&lt;p&gt;Look inside a component that does some real job and you find yourself in the land of wild and unharnessed async JS. Callback hell - yes, promises - yes, &lt;code&gt;async/await&lt;/code&gt; inside the components - oh yes, coming soon. Dataflow you say? Hardly so.&lt;/p&gt;

&lt;p&gt;I suspect that one of the initial syncretic intentions of NoFlo was to split these vertical callback staircases and promise stacks into good old black boxes with wires between them. However, splitting every async call and callback into 2 components is rather expensive, so in practice we rarely do that.&lt;/p&gt;

&lt;p&gt;But could NoFlo help us simplify async code so we don’t have to write so many callbacks or promises? Yes, partially.&lt;/p&gt;

&lt;h3 id=&#34;solutions-5&#34;&gt;Solutions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Thoughtful breakdown of the applications into components&lt;/li&gt;
&lt;li&gt;Use promises inside components&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;coffee-is-cool-but-it-s-es2015-for-most-people-now&#34;&gt;Coffee is cool but it’s ES2015+ for most people now&lt;/h2&gt;

&lt;p&gt;CoffeeScript is really cool, it’s write less do more. Some people complain that all the cool kids are using ES6/7+Babel now and that CoffeeScript is completely abandoned. But it’s simply mature and cool and you still write less and do more with Coffee than with ES6+.&lt;/p&gt;

&lt;p&gt;However, on a historical scale, CoffeeScript is most probably a stale creek. It’s popularity is not going to grow because of the cool kids and everybody busy watching the changes in ES spec. That means, if NoFlo wants to grow its audience, it has to embrace ES2015+ support. No-no, I don’t mean it should be rewritten in *Script (&lt;code&gt;s/*/(Type/Pure/whatever/&lt;/code&gt;), I mean the ecosystem should be very friendly to people coming from ES world. The documents should contain ES examples first and there should be good quality component libraries in ES to be used as reference too.&lt;/p&gt;

&lt;h3 id=&#34;solutions-6&#34;&gt;Solutions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Documentation should be ES-first, CS-second&lt;/li&gt;
&lt;li&gt;Examples and reference libraries in ES&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-s-next&#34;&gt;What&amp;rsquo;s next?&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve been addressing these problems and a few more while maintaining backends in NoFlo. Just like I created &lt;code&gt;WirePattern&lt;/code&gt; back in the days of &lt;code&gt;noflo@0.5.*&lt;/code&gt; (which is going for good with &lt;code&gt;noflo@0.8.*&lt;/code&gt; and the &lt;a href=&#34;http://bergie.iki.fi/blog/noflo-process-api/&#34;&gt;Process API&lt;/a&gt;), I&amp;rsquo;ve created &lt;a href=&#34;https://github.com/trustmaster/noflo-assembly&#34;&gt;NoFlo Assembly Line&lt;/a&gt; which is a combination of design patterns, best practices and a ES6 library that works on top of NoFlo. It&amp;rsquo;s not yet fully released and I plan to do so after NoFlo &lt;code&gt;0.8.0&lt;/code&gt; is officially out.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On NoFlo database applications</title>
      <link>http://blog.kodigy.com/post/on_noflo_db_apps/</link>
      <pubDate>Wed, 27 Jul 2016 14:25:04 +0100</pubDate>
      
      <guid>http://blog.kodigy.com/post/on_noflo_db_apps/</guid>
      <description>

&lt;h1 id=&#34;on-noflo-database-applications&#34;&gt;On NoFlo Database Applications&lt;/h1&gt;

&lt;p&gt;Thinking over common parts of database applications&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.kodigy.com/img/post/on_noflo_db_apps.jpg&#34; alt=&#34;Scrappy notes&#34; /&gt;&lt;/p&gt;

&lt;p&gt;… I came to some conclusions below&lt;/p&gt;

&lt;h2 id=&#34;common-application-architecture&#34;&gt;Common application architecture&lt;/h2&gt;

&lt;h3 id=&#34;steps-common-to-all-route-graphs&#34;&gt;Steps common to all route graphs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The only processing step that is often present and easy to decompose is Validate &lt;em&gt;(fig. I and II)&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;string-of-pearls-or-pipeline-or-request-backbone&#34;&gt;String of pearls or Pipeline or Request backbone&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Request flow should be serial, it simplifies synchronization and understanding of the flow.&lt;/li&gt;
&lt;li&gt;Each bone in the spine of the graph or step on the pipeline can process some data in parallel. But as the flow should be unidirectional, scatter-gather topology &lt;em&gt;(fig. IV)&lt;/em&gt; is preferred over side jobs &lt;em&gt;(fig. III)&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;database-operations&#34;&gt;Database operations&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Database queries are all different across the application. Input data needs to be extracted/filtered first, then inserted into specific parts of the query, then the result rowset needs to be filtered too &lt;em&gt;(fig. V)&lt;/em&gt; to be used down the stream.&lt;/li&gt;
&lt;li&gt;FBP-SQL would need either a lot of components to cover every specific query configuration, or a rather bushy query builder to compose complex queries in the graph.&lt;/li&gt;
&lt;li&gt;Database operations are very granular in the app and appear in any domain of the app, so Flux Store makes no sense.&lt;/li&gt;
&lt;li&gt;Using a single Database component in the graph makes too many wires.&lt;/li&gt;
&lt;li&gt;Using one instance per query uses more memory.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Running web services as NoFlo graphs</title>
      <link>http://blog.kodigy.com/post/noflo_webservices/</link>
      <pubDate>Fri, 23 Jan 2015 14:38:41 +0100</pubDate>
      
      <guid>http://blog.kodigy.com/post/noflo_webservices/</guid>
      <description>

&lt;h1 id=&#34;getting-all-things-noflo&#34;&gt;Getting All Things NoFlo&lt;/h1&gt;

&lt;p&gt;This article describes things which are yet TODO to get the entire server architecture running on NoFlo (and in Flowhub), problems related to them and potential solutions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.kodigy.com/img/post/noflo_all_the_things.png&#34; alt=&#34;NoFlo all the things!&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;request-isolation&#34;&gt;Request Isolation&lt;/h2&gt;

&lt;p&gt;By default there is no isolation between IPs belonging to different user requests in NoFlo networks.&lt;/p&gt;

&lt;h3 id=&#34;solution-1-current-a-new-network-instance-per-request&#34;&gt;Solution 1 (current): a new Network instance per request&lt;/h3&gt;

&lt;p&gt;Express does its job conventionally, while request handlers instantiate NoFlo networks on demand.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Easy to implement&lt;/li&gt;
&lt;li&gt;Good level of isolation without much effort&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Cons&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Doesn’t let us run the whole app as a NoFlo network&lt;/li&gt;
&lt;li&gt;Waste of resources&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We need to move forward from it!&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-2-group-based-synchronization&#34;&gt;Solution 2: group-based synchronization&lt;/h3&gt;

&lt;p&gt;Use the outmost (first in, last out) NoFlo group packet as request identifier. The entire app is a NoFlo graph, requests are born in noflo-xpress components and tagged with UUIDs, then all downstream components need to handle the outmost group carefully to synchronize data belonging to the same request.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Possible with current NoFlo and WirePattern&lt;/li&gt;
&lt;li&gt;Doesn’t hide all the magic under the hood, you see what makes synchronization happen and can override it&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Cons&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If any component of any subnet omits the outmost group or changes group order -&amp;gt; crash! boom! bang!&lt;/li&gt;
&lt;li&gt;Error handling is tricky (see chapter below)&lt;/li&gt;
&lt;li&gt;You still need to keep synchronization details in mind&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;use-cases-for-groups&#34;&gt;Use cases for groups&lt;/h4&gt;

&lt;p&gt;Summarizing here what groups have been (reasonably) used for so far in NoFlo:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Passing request/job IDs the data belongs to.&lt;/li&gt;
&lt;li&gt;Passing XML-like data structures, splitting them into parts and composing back.&lt;/li&gt;
&lt;li&gt;Grouping UI events (&lt;graph&gt;&lt;event&gt;data&lt;/event&gt;&lt;/graph&gt;).&lt;/li&gt;
&lt;li&gt;Tagging data with its source URL.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;groups-in-component-libraries&#34;&gt;Groups in component libraries&lt;/h4&gt;

&lt;p&gt;Most of component libraries were written in NoFlo 0.3 and 0.4 days. Most of them disrespect groups and some of them even have synchronization bugs (e.g. core/Kick is race-prone in some cases).&lt;/p&gt;

&lt;p&gt;Our original plan about it was to run a campaign porting all the libraries to 0.5 and using WirePattern when necessary.&lt;/p&gt;

&lt;p&gt;With group forwarding required in every single component and with synchronization required in every 3rd or 5th, this is going to lead into a huge WirePattern spaghetti dish. The average NoFlo component won’t look elegant anymore.&lt;/p&gt;

&lt;p&gt;My proposal consists of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Build WirePattern into noflo.Component instead of noflo.Helpers.&lt;/li&gt;
&lt;li&gt;Use port attributes to define some of the synchronization properties.&lt;/li&gt;
&lt;li&gt;Enable group forwarding by default.&lt;/li&gt;
&lt;li&gt;Introduce one or multiple &amp;ldquo;process&amp;rdquo; functions per component. Each function has its own “firing pattern” (a constraint on inport events that triggers the function).&lt;/li&gt;
&lt;li&gt;Release these changes in NoFlo 0.6 and then run the library updating hackathon.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-3-request-tokens-as-1st-class-term&#34;&gt;Solution 3: request tokens as 1st class term&lt;/h3&gt;

&lt;p&gt;Application architecture is similar to Solution 2, but implementation is different. Instead of using outmost groups, add a concept of optional &amp;ldquo;request identifiers&amp;rdquo; or “context tokens” to NoFlo itself. Once a context token is attached to a substream, it sticks to each of its IP. Every component isolates data (input, output and internal state) using context tokens as scope keys and forwards context information downstream automatically. By default no context keys are used, so all data is in the same scope just like they didn’t exist. Context tokens are only used in applications which require request isolation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Footnote: contexts are mentioned in Matt Carkci’s Dataflow book, so this idea is not just crazy, it’s known to work.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fixes the group consistency problem of Solution 2.&lt;/li&gt;
&lt;li&gt;This would require minimal to no changes to existing components and subnets as most of context handling is done by NoFlo runtime itself.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One more keyword in NoFlo language, and yet it’s not in &amp;ldquo;classical FBP&amp;rdquo; language either.&lt;/li&gt;
&lt;li&gt;Despite keeping the current NoFlo 0.5 API, it requires heavy changes to WirePattern and other parts of the runtime.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;error-handling-and-synchronization&#34;&gt;Error handling and Synchronization&lt;/h2&gt;

&lt;p&gt;Correct error tracking is tricky in a divergent-convergent graph because an error may happen at any node while other parts of the request may be hanging in other parts of the graph. They have to be pulled together somehow and forwarded back to the client properly.&lt;/p&gt;

&lt;p&gt;To make things more complicated, there are different kinds of errors which need to be handled differently:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Warnings (e.g., input validation errors): it is better to check for as many of these as possible and collect them in a list before sending a response to user.&lt;/li&gt;
&lt;li&gt;Errors (e.g. database record not found, third party service time-out): such errors stop further processing of the request immediately with an error message, but they are considered as a normal part of the application flow.&lt;/li&gt;
&lt;li&gt;Fatals (e.g. undefined variable or database connection is down): such errors not only stop further processing of the request but also raise a kind of notification to a developer that something is going really wrong and most probably human’s attention is needed.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Handling these errors is most likely out of scope of NoFlo itself, but is rather a matter of architecture patterns.&lt;/p&gt;

&lt;h3 id=&#34;solution-1-string-of-pearls&#34;&gt;Solution 1: &amp;ldquo;String of pearls&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;J. Paul Morrison suggests using &amp;ldquo;string of pearls&amp;rdquo; FBP pattern in all applications dealing with requests. In this pattern, all the data for the request is collected within a single substream. The substream floats from one pearl in the string to another (just like on a pipeline). Each pearl on a string may pass the substream to its side processes (e.g. to load missing data, etc.) before forwarding it to the next pearl. Side processes return substreams back to pearls. At the same moment of time the request (and all the data associated with it) belongs to a single process, so if an error occurs, the current pearl just finishes the request without having to gather it from a branchy graph.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Reliability of this pattern has been proved by time and real banking applications. (and JPM :-))&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It encourages concurrent processing of different requests but restricts concurrent processing of the same request. While in some applications parallel tasks would really reduce response time and make users happier.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solution-2-request-processors&#34;&gt;Solution 2: Request processors&lt;/h3&gt;

&lt;p&gt;This pattern is very similar to &amp;ldquo;String of pearls&amp;rdquo; but allows a certain level of divergence-convergence to do parallel processing.&lt;/p&gt;

&lt;p&gt;It introduces Request processors - a special type of processes which own the requests, scatter data to subgraphs and gather them back for a response.&lt;/p&gt;

&lt;p&gt;Request processors make up a &amp;ldquo;backbone&amp;rdquo; of the application. Similar to string of pearls, requests float down the backbone of processors. But when a processor needs some side work to be done for a request, it doesn’t pass it with all the data to a single side process, but rather holds the request and sends the data to its workers with request ID attached. The workers do their job and return the results (and/or errors) to their master. The master then gathers the results and decides either to pass the request to the next processor in the backbone, or to finish it with a response immediately.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pros:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Maintains request consistency just like &amp;ldquo;string of pearls&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Allows parallel computations for the same request.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Cons:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Synchronization code of Request processors is reusable, but its implementation is non-trivial.#&lt;/li&gt;
&lt;li&gt;Caution: thin ice! We don’t know how it will behave in real world.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;programming-motherfucker&#34;&gt;Programming, Motherfucker&lt;/h2&gt;

&lt;p&gt;OK, we are done with theory and fundamental problems. All the rest is just &lt;a href=&#34;http://programming-motherfucker.com&#34;&gt;http://programming-motherfucker.com&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Implement component libraries (e.g., forms, templates, DB queries, etc.)&lt;/li&gt;
&lt;li&gt;Wrap everything in components&lt;/li&gt;
&lt;li&gt;Connect components into graphs&lt;/li&gt;
&lt;li&gt;Convert old graphs from FBP to JSON&lt;/li&gt;
&lt;li&gt;Make sure it runs in Flowhub&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>